<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK Charts to Spotify Playlist Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1db954 0%, #1ed760 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 10px;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #e9ecef;
            height: 30px;
            max-height: 30px;
        }

        .app-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin: 0;
            line-height: 1;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #f8f9fa;
            padding: 3px 8px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
            position: relative;
            cursor: pointer;
            height: 24px;
        }

        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
        }

        .user-details {
            display: flex;
            align-items: center;
        }

        .user-name {
            font-size: 12px;
            font-weight: 600;
            margin: 0;
            color: #333;
            line-height: 1;
        }

        .dropdown-arrow {
            font-size: 10px;
            opacity: 0.7;
            transition: transform 0.2s ease;
        }

        .user-info.open .dropdown-arrow {
            transform: rotate(180deg);
        }

        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px 0;
            min-width: 150px;
            z-index: 1000;
            display: none;
        }

        .user-dropdown.show {
            display: block;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            color: #333;
            text-decoration: none;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
        }

        .dropdown-item.logout {
            color: #dc3545;
        }

        .dropdown-item.logout:hover {
            background: #f8d7da;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            margin-bottom: 10px;
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .info-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .info-value {
            font-size: 14px;
            color: #333;
            font-weight: 600;
        }

        .filter-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .toggle-slider {
            position: relative;
            width: 40px;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            transition: background 0.3s;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .filter-toggle input[type="checkbox"] {
            display: none;
        }

        .filter-toggle input[type="checkbox"]:checked + .toggle-slider {
            background: #1db954;
        }

        .filter-toggle input[type="checkbox"]:checked + .toggle-slider::before {
            transform: translateX(20px);
        }

        .toggle-label {
            font-size: 12px;
            color: #666;
        }

        .filter-info {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }

        .info-icon {
            width: 16px;
            height: 16px;
            opacity: 0.7;
        }

        .playlist-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #1db954;
        }

        .playlist-name {
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }

        .playlist-details {
            font-size: 11px;
            color: #666;
        }

        .playlist-view-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: #1db954;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background-color 0.2s ease;
        }

        .playlist-view-btn:hover {
            background: #1ed760;
        }

        .auth-section {
            text-align: center;
        }

        .auth-section h2 {
            margin-bottom: 10px;
            color: #1db954;
            font-size: 1.5rem;
        }

        .btn {
            background: #1db954;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-small {
            padding: 4px 12px;
            font-size: 12px;
            border-radius: 12px;
            font-weight: 500;
        }

        .btn:hover {
            background: #1ed760;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .single-row-form {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .form-group {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .form-group label {
            display: inline;
            margin-bottom: 0;
            font-weight: 600;
            color: #333;
            font-size: 13px;
            white-space: nowrap;
        }

        .form-group input,
        .form-group select {
            padding: 4px 8px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 13px;
            min-width: 80px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #1db954;
        }

        .form-actions {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .checkbox-group label {
            font-size: 12px;
            margin: 0;
        }

        .user-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .user-info .user-details {
            display: flex;
            align-items: center;
            gap: 15px;
        }


        .user-info .user-text h3 {
            margin: 0;
            color: #333;
        }

        .user-info .user-text p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 10px;
            font-size: 14px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #1db954;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: none;
            font-size: 14px;
        }

        .alert.show {
            display: block;
        }

        .alert-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .alert-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .playlist-result {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }

        .playlist-result.show {
            display: block;
        }

        .playlist-result h3 {
            color: #1db954;
            margin-bottom: 15px;
        }

        .playlist-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .stat {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
        }

        .stat .number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1db954;
        }

        .stat .label {
            font-size: 0.9rem;
            color: #666;
        }

        .playlist-link {
            display: inline-block;
            background: #1db954;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .playlist-link:hover {
            background: #1ed760;
            transform: translateY(-2px);
        }

        .hidden {
            display: none !important;
        }

        .step {
            margin-bottom: 30px;
        }

        .chart-info {
            background: #f8f9fa;
            padding: 4px;
            border-radius: 8px;
            margin-bottom: 4px;
        }

        .chart-info h3 {
            color: #1db954;
            margin-bottom: 4px;
        }

        .chart-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .chart-preview {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .chart-preview h4 {
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, 300px);
            gap: 12px;
            max-height: 500px;
            overflow-y: auto;
            padding: 8px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: white;
        }

        /* Responsive grid adjustments */
        @media (max-width: 768px) {
            .chart-grid {
                grid-template-columns: 1fr;
                gap: 8px;
                padding: 6px;
            }
            
            .chart-info {
                width: 100%;
            }
            
            .spotify-embed-container {
                max-width: 100%;
            }
        }

        @media (min-width: 1200px) {
            .chart-grid {
                grid-template-columns: repeat(auto-fill, 300px);
                gap: 16px;
            }
        }

        .chart-item {
            display: flex;
            flex-direction: column;
            padding: 2px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background: #fafafa;
            transition: all 0.2s ease;
            min-height: 100px;
        }

        .chart-content {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
        }

        .chart-info {
            flex: 1;
            min-width: 0;
        }

        .chart-item:hover {
            background-color: #f0f0f0;
            border-color: #1db954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .chart-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 0;
        }

        .chart-position {
            font-weight: bold;
            color: #1db954;
            background: #1db954;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        .chart-details {
            flex: 1;
        }

        .chart-track-info {
            font-weight: 600;
            color: #333;
            font-size: 13px;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            position: relative;
        }
        
        .chart-track-info:hover {
            background-color: #f0f8ff;
            border-radius: 3px;
        }
        
        .chart-track-info.has-multiple-matches::after {
            content: " ▼";
            color: #666;
            font-size: 10px;
            margin-left: 4px;
            margin: 0;
            padding: 0;
        }
        
        .chart-track-info.has-mismatch {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 3px;
            position: relative;
        }
        
        .chart-track-info.has-mismatch::before {
            content: "⚠️";
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
        }
        
        .mismatch-tooltip {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: #333;
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 1000;
            display: none;
            margin-bottom: 4px;
        }
        
        .chart-track-info.has-mismatch:hover .mismatch-tooltip {
            display: block;
        }
        
        .accept-match-btn {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: #28a745;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1001;
            display: none;
        }
        
        .chart-track-info:hover .accept-match-btn {
            display: block;
        }
        
        .accept-match-btn:hover {
            background: #218838;
        }
        
        .fetch-more-btn {
            position: absolute;
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1001;
            display: none;
        }
        
        .chart-track-info.has-multiple-matches:hover .fetch-more-btn {
            display: block;
        }
        
        .fetch-more-btn:hover {
            background: #0056b3;
        }
        
        .fetch-more-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .spotify-match {
            flex: 1;
            margin-left: 15px;
            padding: 6px 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .album-cover-container {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
            min-height: 64px;
        }

        .album-cover-container:hover {
            transform: scale(1.02);
        }

        .album-cover {
            width: 64px;
            height: 64px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .track-info {
            margin-left: 12px;
            flex: 1;
            color: white;
            min-width: 0; /* Allow flex item to shrink */
        }

        .track-title {
            font-weight: 600;
            font-size: 14px;
            line-height: 1.3;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: help;
        }

        .track-artist {
            font-size: 12px;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: help;
        }

        .single-player-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 450px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            padding: 16px;
            z-index: 1000;
            display: none !important;
        }

        .single-player-container.show {
            display: block !important;
        }

        .player-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 18px;
            color: #999;
            cursor: pointer;
            padding: 4px;
            z-index: 1001;
        }

        .player-close:hover {
            color: #333;
        }

        .player-iframe {
            width: 100%;
            height: 400px;
            border: none;
            border-radius: 6px;
            min-width: 0;
        }


        .spotify-preview {
            margin-top: 4px;
        }

        .spotify-embed-container {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .spotify-embed-container iframe {
            border-radius: 6px;
            border: none;
            width: 100%;
            height: 80px;
        }

        .match-selector {
            margin-bottom: 4px;
            display: none; /* Hidden by default */
        }
        
        .match-selector.expanded {
            display: block; /* Show when expanded */
        }

        .match-dropdown {
            width: 100%;
            padding: 2px 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            background: white;
            color: #333;
        }

        .match-dropdown:focus {
            outline: none;
            border-color: #1db954;
        }


        .spotify-no-match {
            width: 100%;
            padding: 2px 4px;
            background: #fff3cd;
            border-radius: 3px;
            border-left: 2px solid #ffc107;
            text-align: center;
            flex-shrink: 0;
        }

        .no-match-text {
            color: #856404;
            font-size: 0.8em;
            font-weight: 500;
            line-height: 1.1;
        }

        .error-text {
            color: #721c24;
            font-size: 0.8em;
            display: block;
            margin-top: 4px;
        }

        .spotify-loading {
            flex: 1;
            margin-left: 15px;
            padding: 6px 8px;
            background: #e3f2fd;
            border-radius: 4px;
            border-left: 2px solid #2196f3;
            text-align: center;
        }

        .loading-text {
            color: #1976d2;
            font-size: 0.9em;
            font-weight: 500;
        }

        .playlist-creation {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: nowrap;
        }

        .playlist-creation .btn {
            white-space: nowrap;
            min-width: fit-content;
            padding: 8px 12px;
            font-size: 14px;
        }

        #backToStep1Btn {
            min-width: 120px;
            padding: 8px 12px;
        }

        .existing-playlists {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .existing-playlists h4 {
            color: #333;
            margin-bottom: 15px;
        }

        .playlist-list {
            display: grid;
            gap: 10px;
        }

        .playlist-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .playlist-item:hover {
            border-color: #1db954;
            background: #f8f9fa;
        }

        .playlist-item.selected {
            border-color: #1db954;
            background: #e8f5e8;
        }

        .playlist-info h5 {
            margin: 0 0 5px 0;
            color: #333;
        }

        .playlist-info p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }

        .chart-header h4 {
            margin: 0;
        }

        .selection-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .selected-count {
            font-size: 0.9rem;
            color: #666;
            font-weight: 600;
        }


        .update-options {
            margin-top: 0;
            text-align: center;
        }

        .playlist-selector {
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background: white;
            min-width: 180px;
        }

        .playlist-creation .checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            white-space: nowrap;
            margin-left: 8px;
        }

        .auth-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .auth-notice h4 {
            color: #856404;
            margin: 0 0 10px 0;
        }

        .auth-notice p {
            color: #856404;
            margin: 5px 0;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .form-row {
                flex-direction: column;
                gap: 0;
            }

            .user-info {
                flex-direction: column;
                text-align: center;
                gap: 15px;
            }

            .playlist-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .chart-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .playlist-creation {
                flex-direction: column;
                align-items: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            .playlist-creation .btn {
                width: 100%;
                max-width: 300px;
            }

            .playlist-creation .checkbox-group {
                font-size: 11px;
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">

        <!-- Alert Messages -->
        <div id="alert" class="alert"></div>

        <!-- Authentication Section -->
        <div id="authSection" class="card auth-section">
            <h2>Connect to Spotify</h2>
            <p>Log in to your Spotify account to create playlists</p>
            <button id="loginBtn" class="btn">Login with Spotify</button>
        </div>

        <!-- Main App Section -->
        <div id="appSection" class="card hidden">
            <!-- Page Header -->
            <div class="page-header">
                <div class="app-title">🎵 UK Charts to Spotify</div>
                <div id="userInfo" class="user-info" style="display: none;">
                    <img id="userAvatar" class="user-avatar" src="" alt="User Avatar">
                    <div class="user-details">
                        <div id="userName" class="user-name"></div>
                    </div>
                    <span class="dropdown-arrow">▼</span>
                    <div class="user-dropdown">
                        <a href="#" class="dropdown-item logout" id="logoutBtn">
                            <span>🚪</span>
                            Logout
                        </a>
                    </div>
                </div>
            </div>

            <!-- Step 1: Chart Selection -->
            <div id="step1" class="step">
                <h2>Step 1: Select Chart Year</h2>
                <form id="chartForm">
                    <div class="single-row-form">
                        <div class="form-group">
                            <label for="year">Year:</label>
                            <select id="year" name="year" required>
                                <option value="">Loading...</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="playlistName">Name:</label>
                            <input type="text" id="playlistName" name="playlistName" placeholder="Auto-generated">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="isPublic" name="isPublic">
                            <label for="isPublic">Public</label>
                        </div>
                        
                        <div class="form-actions">
                            <button type="submit" id="loadChartBtn" class="btn btn-small">Load</button>
                            <button type="button" id="forceRefreshBtn" class="btn btn-secondary btn-small">Refresh</button>
                        </div>
                    </div>
                </form>
            </div>

            <!-- Step 2: Chart Preview -->
            <div id="step2" class="step hidden">
                <!-- Compact Info Bar -->
                <div class="info-bar">
                    <div class="info-section">
                        <span class="info-label">Chart:</span>
                        <span id="chartTitle" class="info-value">UK Top 100 - 2024</span>
                    </div>
                    <div class="info-section">
                        <span class="info-label">Tracks:</span>
                        <span id="totalTracks" class="info-value">100</span>
                    </div>
                    <div class="info-section">
                        <label class="filter-toggle">
                            <input type="checkbox" id="showAllTracks">
                            <span class="toggle-slider"></span>
                            <span class="toggle-label">Show all</span>
                        </label>
                        <span class="filter-info" id="filterInfo">Showing tracks needing verification</span>
                    </div>
                    <div class="info-section">
                        <span class="info-label">Year:</span>
                        <span id="chartYear" class="info-value">2024</span>
                    </div>
                    <div class="info-section">
                        <span class="info-icon">📦</span>
                        <span id="cacheStatus" class="info-label">Cached</span>
                    </div>
                    <div id="playlistInfo" class="playlist-info" style="display: none;">
                        <span class="playlist-name" id="playlistName"></span>
                        <span class="playlist-details" id="playlistDetails"></span>
                        <a id="playlistViewBtn" class="playlist-view-btn" href="#" target="_blank">View</a>
                    </div>
                </div>

                <!-- Existing Playlists (Hidden by default, shown when needed) -->
                <div id="existingPlaylists" class="existing-playlists hidden">
                    <div id="playlistList" class="playlist-list">
                        <!-- Existing playlists will be populated here -->
                    </div>
                </div>

                <!-- Authentication Notice -->
                <div id="authNotice" class="auth-notice hidden">
                    <div class="notice-content">
                        <h4>🔐 Login Required for Playlist Management</h4>
                        <p>To check for existing playlists and update them, you need to log in to Spotify first.</p>
                        <p>You can still view and select tracks without logging in, but you'll need to authenticate to create or update playlists.</p>
                    </div>
                </div>

                <!-- Chart Preview with Selection -->
                <div id="chartPreview" class="chart-preview">
                    <div class="chart-header">
                        <h4>Select Tracks to Add</h4>
                        <div class="selection-controls">
                            <button id="selectAllBtn" class="btn btn-small">Select All</button>
                            <button id="selectNoneBtn" class="btn btn-small btn-secondary">Select None</button>
                            <span id="selectedCount" class="selected-count">0 tracks selected</span>
                        </div>
                    </div>
                    <div id="chartList" class="chart-grid">
                        <!-- Chart items will be populated here -->
                    </div>
                </div>

                <!-- Playlist Creation/Update -->
                <div class="playlist-creation">
                    <div id="createNewSection">
                        <button id="createPlaylistBtn" class="btn">Create New Playlist</button>
                    </div>
                    <div id="updateExistingSection" class="hidden">
                        <select id="playlistSelector" class="playlist-selector">
                            <option value="">Select a playlist...</option>
                        </select>
                        <button id="updatePlaylistBtn" class="btn">Add to Playlist</button>
                        <label class="checkbox-group">
                            <input type="checkbox" id="replaceAllTracks">
                            <span>Replace all tracks</span>
                        </label>
                    </div>
                    <button id="backToStep1Btn" class="btn btn-secondary">Back to Step 1</button>
                </div>
            </div>

            <!-- Loading State -->
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p id="loadingText">Creating your playlist...</p>
            </div>

            <!-- Playlist Result -->
            <div id="playlistResult" class="playlist-result">
                <h3>🎉 Playlist Created Successfully!</h3>
                <div class="playlist-stats">
                    <div class="stat">
                        <div class="number" id="tracksFound">0</div>
                        <div class="label">Tracks Found</div>
                    </div>
                    <div class="stat">
                        <div class="number" id="tracksSearched">0</div>
                        <div class="label">Tracks Searched</div>
                    </div>
                    <div class="stat">
                        <div class="number" id="playlistYear">-</div>
                        <div class="label">Year</div>
                    </div>
                </div>
                <a id="playlistLink" href="#" target="_blank" class="playlist-link">Open in Spotify</a>
            </div>
        </div>
    </div>

    <!-- Single Spotify Player -->
    <div id="singlePlayer" class="single-player-container">
        <button id="playerClose" class="player-close" onclick="closePlayer()">×</button>
        <iframe id="playerIframe" class="player-iframe" src="" allow="encrypted-media"></iframe>
    </div>

    <script>
        class UKChartsApp {
            constructor() {
                this.isAuthenticated = false;
                this.user = null;
                this.currentChartData = null;
                this.tracksLoaded = false;
                this.init();
            }

            async init() {
                this.setupEventListeners();
                await this.checkAuthentication();
                await this.loadYears();
                this.handleURLParams();
            }

            setupEventListeners() {
                document.getElementById('loginBtn').addEventListener('click', () => this.login());
                document.getElementById('logoutBtn').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.logout();
                });
                document.getElementById('chartForm').addEventListener('submit', (e) => this.loadChartData(e));
                document.getElementById('forceRefreshBtn').addEventListener('click', () => this.forceRefreshChart());
                document.getElementById('createPlaylistBtn').addEventListener('click', () => this.createPlaylist());
                document.getElementById('updatePlaylistBtn').addEventListener('click', () => this.updatePlaylist());
                document.getElementById('backToStep1Btn').addEventListener('click', () => this.backToStep1());
                document.getElementById('selectAllBtn').addEventListener('click', () => this.selectAllTracks());
                document.getElementById('selectNoneBtn').addEventListener('click', () => this.selectNoTracks());
                document.getElementById('year').addEventListener('change', () => this.updatePlaylistName());
                document.getElementById('showAllTracks').addEventListener('change', () => this.toggleTrackFilter());
                
                // User dropdown functionality
                const userInfo = document.getElementById('userInfo');
                userInfo.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleUserDropdown();
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', () => {
                    this.closeUserDropdown();
                });
            }

            async checkAuthentication() {
                try {
                    const response = await fetch('/api/user');
                    if (response.ok) {
                        const data = await response.json();
                        this.isAuthenticated = true;
                        this.user = data.user;
                        this.showApp();
                    } else {
                        this.showAuth();
                    }
                } catch (error) {
                    console.error('Auth check failed:', error);
                    this.showAuth();
                }
            }

            async loadYears() {
                try {
                    const response = await fetch('/api/years');
                    if (response.ok) {
                        const data = await response.json();
                        const yearSelect = document.getElementById('year');
                        yearSelect.innerHTML = '<option value="">Select a year...</option>';
                        
                        data.years.forEach(year => {
                            const option = document.createElement('option');
                            option.value = year;
                            option.textContent = year;
                            yearSelect.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('Failed to load years:', error);
                    this.showAlert('Failed to load available years', 'error');
                }
            }

            login() {
                window.location.href = '/api/auth/spotify';
            }

            async logout() {
                try {
                    await fetch('/api/logout', { method: 'POST' });
                    this.isAuthenticated = false;
                    this.user = null;
                    this.showAuth();
                    this.showAlert('Logged out successfully', 'success');
                } catch (error) {
                    console.error('Logout failed:', error);
                    this.showAlert('Logout failed', 'error');
                }
            }

            showAuth() {
                document.getElementById('authSection').classList.remove('hidden');
                document.getElementById('appSection').classList.add('hidden');
            }

            showApp() {
                document.getElementById('authSection').classList.add('hidden');
                document.getElementById('appSection').classList.remove('hidden');
                this.updateUserInfo();
            }

            updateUserInfo() {
                if (this.user) {
                    document.getElementById('userName').textContent = this.user.display_name || this.user.id;
                    
                    const avatar = document.getElementById('userAvatar');
                    if (this.user.images && this.user.images.length > 0) {
                        avatar.src = this.user.images[0].url;
                        avatar.alt = this.user.display_name || this.user.id;
                    } else {
                        avatar.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTIiIGZpbGw9IiMxZGI5NTQiLz4KPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxMiIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj4/PC90ZXh0Pgo8L3N2Zz4K';
                        avatar.alt = this.user.display_name || this.user.id;
                    }
                    
                    // Show user info in top bar
                    document.getElementById('userInfo').style.display = 'flex';
                }
            }

            toggleUserDropdown() {
                const userInfo = document.getElementById('userInfo');
                const dropdown = userInfo.querySelector('.user-dropdown');
                
                if (dropdown.classList.contains('show')) {
                    this.closeUserDropdown();
                } else {
                    this.openUserDropdown();
                }
            }

            openUserDropdown() {
                const userInfo = document.getElementById('userInfo');
                const dropdown = userInfo.querySelector('.user-dropdown');
                
                userInfo.classList.add('open');
                dropdown.classList.add('show');
            }

            closeUserDropdown() {
                const userInfo = document.getElementById('userInfo');
                const dropdown = userInfo.querySelector('.user-dropdown');
                
                userInfo.classList.remove('open');
                dropdown.classList.remove('show');
            }

            updatePlaylistName() {
                const year = document.getElementById('year').value;
                const playlistName = document.getElementById('playlistName');
                
                if (year && !playlistName.value) {
                    playlistName.placeholder = `UK Top 100 - ${year}`;
                }
            }

            toggleTrackFilter() {
                const showAllCheckbox = document.getElementById('showAllTracks');
                const filterInfo = document.getElementById('filterInfo');
                const showAll = showAllCheckbox.checked;
                
                console.log(`🔍 Toggle filter: showAll = ${showAll}`);
                
                if (showAll) {
                    filterInfo.textContent = 'Showing all tracks';
                    this.showAllTracks();
                } else {
                    filterInfo.textContent = 'Showing tracks needing verification';
                    this.showTracksNeedingVerification();
                }
            }

            showTracksNeedingVerification() {
                const chartList = document.getElementById('chartList');
                if (!chartList) {
                    console.log('❌ Chart list not found');
                    return;
                }
                
                const trackElements = chartList.querySelectorAll('.chart-item');
                console.log(`🔍 Found ${trackElements.length} track elements for verification filter`);
                
                if (trackElements.length === 0) {
                    console.log('❌ No track elements found - tracks may not be loaded yet');
                    return;
                }
                
                let visibleCount = 0;
                trackElements.forEach(element => {
                    const trackInfo = element.querySelector('.chart-track-info');
                    const hasMismatch = trackInfo && trackInfo.classList.contains('has-mismatch');
                    
                    // Only show tracks that have mismatches (need verification)
                    if (hasMismatch) {
                        element.style.display = 'flex';
                        visibleCount++;
                    } else {
                        element.style.display = 'none';
                    }
                });
                
                console.log(`🔍 Showing ${visibleCount} tracks needing verification`);
            }

            showAllTracks() {
                if (!this.tracksLoaded) {
                    console.log('❌ Tracks not loaded yet - cannot apply filter');
                    return;
                }
                
                const chartList = document.getElementById('chartList');
                if (!chartList) {
                    console.log('❌ Chart list not found');
                    return;
                }
                
                const trackElements = chartList.querySelectorAll('.chart-item');
                console.log(`🔍 Found ${trackElements.length} track elements for show all filter`);
                
                if (trackElements.length === 0) {
                    console.log('❌ No track elements found - tracks may not be loaded yet');
                    console.log('🔍 Chart list innerHTML length:', chartList.innerHTML.length);
                    console.log('🔍 Chart list children count:', chartList.children.length);
                    return;
                }
                
                let shownCount = 0;
                trackElements.forEach((element, index) => {
                    // Force show all tracks regardless of previous state
                    element.style.display = 'flex';
                    shownCount++;
                    
                    // Log first few for debugging
                    if (index < 3) {
                        console.log(`🔍 Track ${index + 1}: ${element.id} - display set to flex`);
                    }
                });
                
                console.log(`🔍 Showing all ${shownCount} tracks`);
            }

            async loadChartData(event, forceRefresh = false) {
                if (event) event.preventDefault();
                
                // Reset tracks loaded flag
                this.tracksLoaded = false;
                
                const year = document.getElementById('year').value;
                
                if (!year) {
                    this.showAlert('Please select a year', 'error');
                    return;
                }

                // Update URL parameters
                this.updateURL(year, forceRefresh);

                // Check cache first (unless force refresh)
                if (!forceRefresh) {
                    const cachedData = this.getCachedChartData(year);
                    if (cachedData) {
                        console.log(`📦 Using cached data for ${year}`);
                        this.selectedYear = year; // Set selected year for caching
                        this.showLoading(true, 'Loading cached chart data...');
                        this.hidePlaylistResult();
                        
                        try {
                            // Check for existing playlists (only if authenticated)
                            this.showLoading(true, 'Checking for existing playlists...');
                            const playlistResponse = await fetch(`/api/check-playlist/${year}`);
                            const playlistData = await playlistResponse.json();

                            if (playlistResponse.ok) {
                                this.currentChartData = cachedData;
                                this.currentExistingPlaylists = playlistData.existingPlaylists || [];
                                this.showChartPreview(cachedData, year, playlistData.hasExisting, true, playlistData.authenticated);
                                this.showStep2();
                                this.showAlert(`Loaded ${cachedData.tracksFound} tracks from ${year} chart (cached)`, 'success');
                            } else {
                                this.showAlert(playlistData.error || 'Failed to check existing playlists', 'error');
                            }
                        } catch (error) {
                            console.error('Load cached chart error:', error);
                            this.showAlert('Error loading cached data. Please try again.', 'error');
                        } finally {
                            this.showLoading(false);
                        }
                        return;
                    }
                }

                this.showLoading(true, forceRefresh ? 'Refreshing chart data...' : 'Loading chart data...');
                this.hidePlaylistResult();

                try {
                    // Load chart data from server
                    const chartResponse = await fetch(`/api/test-chart/${year}`);
                    const chartData = await chartResponse.json();

                    if (!chartResponse.ok) {
                        this.showAlert(chartData.error || 'Failed to load chart data', 'error');
                        return;
                    }

                    // Cache the data if we got 100 tracks
                    if (chartData.tracksFound === 100) {
                        this.cacheChartData(year, chartData);
                        console.log(`💾 Cached data for ${year}`);
                    }

                    // Check for existing playlists (only if authenticated)
                    this.showLoading(true, 'Checking for existing playlists...');
                    const playlistResponse = await fetch(`/api/check-playlist/${year}`);
                    const playlistData = await playlistResponse.json();

                    if (playlistResponse.ok) {
                this.currentChartData = chartData;
                this.currentExistingPlaylists = playlistData.existingPlaylists || [];
                this.selectedYear = year; // Set selected year for caching
                this.showChartPreview(chartData, year, playlistData.hasExisting, false, playlistData.authenticated);
                this.showStep2();
                        this.showAlert(`Loaded ${chartData.tracksFound} tracks from ${year} chart${forceRefresh ? ' (refreshed)' : ''}`, 'success');
                    } else {
                        this.showAlert(playlistData.error || 'Failed to check existing playlists', 'error');
                    }
                } catch (error) {
                    console.error('Load chart error:', error);
                    this.showAlert('Network error. Please try again.', 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            async forceRefreshChart() {
                const year = document.getElementById('year').value;
                if (!year) {
                    this.showAlert('Please select a year first', 'error');
                    return;
                }

                // Update URL parameters with refresh flag
                this.updateURL(year, true);
                
                // Clear cache for this year (both chart data and Spotify matches)
                this.clearCachedChartData(year);
                const spotifyCacheKey = `spotify_matches_${year}`;
                localStorage.removeItem(spotifyCacheKey);
                console.log(`🗑️ Cleared all caches for ${year}`);
                
                // Set force refresh flag
                this.forceRefresh = true;
                
                // Load fresh data
                await this.loadChartData(null, true);
                
                // Reset force refresh flag
                this.forceRefresh = false;
            }

            showChartPreview(data, year, hasExistingPlaylists = false, isCached = false, isAuthenticated = false) {
                // Update chart info in compact info bar
                document.getElementById('chartTitle').textContent = `UK Top 100 - ${year}`;
                document.getElementById('totalTracks').textContent = data.tracksFound;
                document.getElementById('chartYear').textContent = year;
                
                // Show/hide cache status
                const cacheStatus = document.getElementById('cacheStatus');
                if (isCached) {
                    cacheStatus.style.display = 'inline';
                } else {
                    cacheStatus.style.display = 'none';
                }
                
                // Show/hide playlist info in compact bar
                const playlistInfo = document.getElementById('playlistInfo');
                if (hasExistingPlaylists && this.currentExistingPlaylists.length > 0) {
                    const playlist = this.currentExistingPlaylists[0]; // Show first playlist
                    document.getElementById('playlistName').textContent = playlist.name;
                    document.getElementById('playlistDetails').textContent = `${playlist.tracks?.total || 0} tracks • ${playlist.owner?.display_name || 'Unknown'}`;
                    document.getElementById('playlistViewBtn').href = playlist.external_urls?.spotify || '#';
                    playlistInfo.style.display = 'flex';
                } else {
                    playlistInfo.style.display = 'none';
                }

                // Hide the existing playlists section since we show info in compact bar
                const existingPlaylistsDiv = document.getElementById('existingPlaylists');
                const authNotice = document.getElementById('authNotice');
                const createNewSection = document.getElementById('createNewSection');
                const updateExistingSection = document.getElementById('updateExistingSection');

                // Always hide the existing playlists section - we show info in compact bar instead
                existingPlaylistsDiv.classList.add('hidden');

                if (isAuthenticated) {
                    if (hasExistingPlaylists && this.currentExistingPlaylists.length > 0) {
                        // User is authenticated and has existing playlists
                        authNotice.classList.add('hidden');
                        createNewSection.classList.remove('hidden');
                        updateExistingSection.classList.remove('hidden');
                        
                        // Populate playlist selector
                        this.populatePlaylistSelector();
                    } else {
                        // User is authenticated but no existing playlists found
                        authNotice.classList.add('hidden');
                        createNewSection.classList.remove('hidden');
                        updateExistingSection.classList.add('hidden');
                    }
                } else {
                    // User is not authenticated
                    authNotice.classList.remove('hidden');
                    createNewSection.classList.add('hidden');
                    updateExistingSection.classList.add('hidden');
                }

                // Show all tracks with checkboxes
                this.displayAllTracks(data.tracks);
            }

            showExistingPlaylists() {
                const playlistList = document.getElementById('playlistList');
                playlistList.innerHTML = '';

                this.currentExistingPlaylists.forEach(playlist => {
                    const playlistElement = document.createElement('div');
                    playlistElement.className = 'playlist-item';
                    playlistElement.dataset.playlistId = playlist.id;
                    playlistElement.innerHTML = `
                        <div class="playlist-info">
                            <h5>${playlist.name}</h5>
                            <p>${playlist.tracks?.total || 0} tracks • ${playlist.owner?.display_name || 'Unknown'}</p>
                        </div>
                        <div class="playlist-actions">
                            <a href="${playlist.external_urls?.spotify}" target="_blank" class="btn btn-small">View on Spotify</a>
                        </div>
                    `;
                    
                    playlistElement.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'A') {
                            this.selectPlaylist(playlist.id);
                        }
                    });
                    
                    playlistList.appendChild(playlistElement);
                });
            }

            selectPlaylist(playlistId) {
                // Remove selection from all playlists
                document.querySelectorAll('.playlist-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Select the clicked playlist
                const selectedPlaylist = document.querySelector(`[data-playlist-id="${playlistId}"]`);
                if (selectedPlaylist) {
                    selectedPlaylist.classList.add('selected');
                    this.selectedPlaylistId = playlistId;
                }
            }

            async displayAllTracks(tracks) {
                const chartList = document.getElementById('chartList');
                chartList.innerHTML = '';

                // Show tracks immediately without Spotify matches
                this.showTracksWithoutMatches(tracks);

                // Start loading Spotify matches asynchronously
                this.loadSpotifyMatchesAsync(tracks);
            }

            async loadSpotifyMatchesAsync(tracks) {
                try {
                    console.log('🎵 Starting async Spotify matching...');
                    console.log('📤 Processing', tracks.length, 'tracks in batches of 10');
                    
                    // Check for cached Spotify matches first
                    const year = this.selectedYear;
                    const cacheKey = `spotify_matches_${year}`;
                    const cachedMatches = localStorage.getItem(cacheKey);
                    
                    if (cachedMatches && !this.forceRefresh) {
                        console.log('📦 Using cached Spotify matches for', year);
                        const matches = JSON.parse(cachedMatches);
                        this.currentMatches = matches; // Store for dropdown selection
                        
                        // Load accepted matches from cache
                        this.loadAcceptedMatchesFromCache(year);
                        
                        this.updateTracksWithMatches(matches);
                        return;
                    }
                    
                    if (this.forceRefresh) {
                        console.log('🔄 Force refresh: clearing Spotify match cache for', year);
                        localStorage.removeItem(cacheKey);
                        localStorage.removeItem(`accepted_matches_${year}`); // Also clear accepted matches
                    }
                    
                    // Also clear cache if it doesn't have the new artists array format
                    if (cachedMatches && !this.forceRefresh) {
                        try {
                            const matches = JSON.parse(cachedMatches);
                            const firstMatch = matches.find(m => m.spotifyMatches && m.spotifyMatches.length > 0);
                            if (firstMatch && firstMatch.spotifyMatches[0] && !firstMatch.spotifyMatches[0].artists) {
                                console.log('🔄 Clearing old cache format (no artists array) for', year);
                                localStorage.removeItem(cacheKey);
                                cachedMatches = null;
                            }
                        } catch (e) {
                            console.log('🔄 Clearing corrupted cache for', year);
                            localStorage.removeItem(cacheKey);
                            cachedMatches = null;
                        }
                    }
                    
                    // Safely encode tracks data to prevent JSON parsing issues
                    const safeTracks = tracks.map(track => ({
                        position: track.position,
                        title: track.title,
                        artist: track.artist,
                        searchQuery: track.searchQuery
                    }));
                    
                    console.log('🔒 Safely encoded tracks data');
                    
                    // Process tracks in batches of 10, with 3 batches running in parallel
                    const batchSize = 10;
                    const parallelBatches = 3;
                    const totalBatches = Math.ceil(safeTracks.length / batchSize);
                    let allMatches = [];
                    
                    // Create all batches first
                    const batches = [];
                    for (let i = 0; i < safeTracks.length; i += batchSize) {
                        batches.push(safeTracks.slice(i, i + batchSize));
                    }
                    
                    // Process batches in parallel groups
                    for (let i = 0; i < batches.length; i += parallelBatches) {
                        const currentBatches = batches.slice(i, i + parallelBatches);
                        const groupNumber = Math.floor(i / parallelBatches) + 1;
                        const totalGroups = Math.ceil(batches.length / parallelBatches);
                        
                        console.log(`🚀 Processing parallel group ${groupNumber}/${totalGroups} (${currentBatches.length} batches)`);
                        
                        // Create promises for all batches in this parallel group
                        const batchPromises = currentBatches.map(async (batch, batchIndex) => {
                            const actualBatchNumber = i + batchIndex + 1;
                            console.log(`🎵 Processing batch ${actualBatchNumber}/${totalBatches} (${batch.length} tracks)`);
                            
                            try {
                                // Test JSON stringification for this batch
                                const testJson = JSON.stringify({ tracks: batch });
                                console.log(`✅ Batch ${actualBatchNumber} JSON stringification successful, length:`, testJson.length);
                                
                                // Fetch Spotify matches for this batch
                                const response = await fetch('/api/match-tracks', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    body: testJson
                                });

                                console.log(`📡 Batch ${actualBatchNumber} response received, status:`, response.status, response.statusText);
                                
                                if (!response.ok) {
                                    console.error(`❌ Batch ${actualBatchNumber} HTTP error:`, response.status, response.statusText);
                                    const errorText = await response.text();
                                    console.error(`❌ Batch ${actualBatchNumber} error response body:`, errorText);
                                    return null; // Return null for failed batches
                                }

                                const matchData = await response.json();
                                console.log(`📊 Batch ${actualBatchNumber} match data received:`, matchData);

                                if (matchData.success && matchData.matches) {
                                    console.log(`✅ Batch ${actualBatchNumber} loaded ${matchData.matches.length} matches`);
                                    return matchData.matches;
                                } else {
                                    console.warn(`⚠️ Batch ${actualBatchNumber} failed:`, matchData.error);
                                    return null;
                                }
                                
                            } catch (batchError) {
                                console.error(`❌ Batch ${actualBatchNumber} error:`, batchError);
                                return null; // Return null for failed batches
                            }
                        });
                        
                        // Wait for all batches in this parallel group to complete
                        const batchResults = await Promise.all(batchPromises);
                        
                        // Process results and update UI
                        batchResults.forEach(matches => {
                            if (matches) {
                                allMatches = allMatches.concat(matches);
                                this.currentMatches = allMatches; // Store for dropdown selection
                                // Update the display with matches from this batch
                                this.updateTracksWithMatches(matches);
                            }
                        });
                        
                        // Add delay between parallel groups to avoid overwhelming the server
                        if (i + parallelBatches < batches.length) {
                            console.log('⏳ Waiting 300ms before next parallel group...');
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                    }
                    
                    console.log(`🎉 Completed all batches! Total matches: ${allMatches.length}/${tracks.length}`);
                    
                    // Cache the Spotify matches for this year
                    if (allMatches.length > 0) {
                        const year = this.selectedYear;
                        const cacheKey = `spotify_matches_${year}`;
                        localStorage.setItem(cacheKey, JSON.stringify(allMatches));
                        console.log(`💾 Cached ${allMatches.length} Spotify matches for ${year}`);
                        
                        // Load accepted matches from cache
                        this.loadAcceptedMatchesFromCache(year);
                    }

                } catch (error) {
                    console.error('❌ Error in batch processing:', error);
                    console.error('❌ Error details:', error.message, error.stack);
                    this.showAlert('Failed to load Spotify matches: ' + error.message, 'error');
                }
            }

            showTracksWithMatches(matches) {
                const chartList = document.getElementById('chartList');
                chartList.innerHTML = '';

                matches.forEach(match => {
                    const trackElement = document.createElement('div');
                    trackElement.className = 'chart-item';
                    
                    let spotifyInfo = '';
                    if (match.hasMatch && match.spotifyMatch) {
                        const spotify = match.spotifyMatch;
                        spotifyInfo = `
                            <div class="spotify-match">
                                <div class="spotify-title">${spotify.name}</div>
                                <div class="spotify-artist">${spotify.artists.map(a => a.name).join(', ')}</div>
                                <div class="spotify-album">${spotify.album.name}</div>
                                <div class="spotify-preview">
                                    ${spotify.preview_url ? 
                                        `<audio controls preload="none" class="preview-audio">
                                            <source src="${spotify.preview_url}" type="audio/mpeg">
                                        </audio>` : 
                                        '<span class="no-preview">No preview available</span>'
                                    }
                                </div>
                            </div>
                        `;
                    } else {
                        spotifyInfo = `
                            <div class="spotify-no-match">
                                <span class="no-match-text">No Spotify match found</span>
                                ${match.error ? `<span class="error-text">(${match.error})</span>` : ''}
                            </div>
                        `;
                    }

                    trackElement.innerHTML = `
                        <input type="checkbox" id="track-${match.position}" data-position="${match.position}" checked>
                        <div class="chart-position">${match.position}</div>
                        <div class="chart-details">
                            <div class="chart-title">${match.title}</div>
                            <div class="chart-artist">${match.artist}</div>
                        </div>
                        ${spotifyInfo}
                    `;
                    
                    // Add event listener for checkbox changes
                    const checkbox = trackElement.querySelector('input[type="checkbox"]');
                    checkbox.addEventListener('change', () => this.updateSelectedCount());
                    
                    chartList.appendChild(trackElement);
                });

                this.updateSelectedCount();
            }

            showTracksWithoutMatches(tracks) {
                const chartList = document.getElementById('chartList');
                chartList.innerHTML = '';

                tracks.forEach(track => {
                    const trackElement = document.createElement('div');
                    trackElement.className = 'chart-item';
                    trackElement.id = `track-element-${track.position}`;
                    trackElement.innerHTML = `
                        <div class="chart-header">
                            <div class="chart-position">${track.position}</div>
                            <div class="chart-info">
                                <div class="chart-details">
                                    <div class="chart-track-info" title="${track.title} - ${track.artist}">${track.title} - ${track.artist}</div>
                                </div>
                            </div>
                            <input type="checkbox" id="track-${track.position}" data-position="${track.position}" checked>
                        </div>
                        <div class="chart-content">
                            <div class="spotify-loading">
                                <span class="loading-text">Loading Spotify match...</span>
                            </div>
                        </div>
                    `;
                    
                    // Add event listener for checkbox changes
                    const checkbox = trackElement.querySelector('input[type="checkbox"]');
                    checkbox.addEventListener('change', () => this.updateSelectedCount());
                    
                    // Add click handler for track info (for expanding match selector)
                    const trackInfo = trackElement.querySelector('.chart-track-info');
                    trackInfo.addEventListener('click', () => this.toggleMatchSelector(track.position));
                    
                    chartList.appendChild(trackElement);
                });

                this.updateSelectedCount();
            }

            updateTracksWithMatches(matches) {
                console.log('🔄 Updating tracks with matches:', matches.length);
                
                matches.forEach(match => {
                    const trackElement = document.getElementById(`track-element-${match.position}`);
                    if (!trackElement) {
                        console.warn(`❌ Track element not found for position ${match.position}`);
                        return;
                    }

                    const spotifyContainer = trackElement.querySelector('.spotify-loading, .spotify-embed-container, .spotify-no-match');
                    if (!spotifyContainer) {
                        console.warn(`❌ Spotify container not found for position ${match.position}`);
                        return;
                    }

                    let spotifyInfo = '';
                    if (match.hasMatch && match.spotifyMatches && match.spotifyMatches.length > 0) {
                        const selectedIndex = match.selectedMatch || 0;
                        const selectedTrack = match.spotifyMatches[selectedIndex];
                        console.log(`✅ Updating track ${match.position} with match: ${selectedTrack.name}`);
                        
                        // Show match selector if there are multiple matches (hidden by default)
                        let matchSelector = '';
                        if (match.spotifyMatches.length > 1) {
                            matchSelector = `
                                <div class="match-selector" id="match-selector-${match.position}">
                                    <select class="match-dropdown" data-position="${match.position}">
                                        ${match.spotifyMatches.map((track, index) => 
                                            `<option value="${index}" ${index === selectedIndex ? 'selected' : ''}>
                                                ${track.name} - ${track.artist} (${track.album})
                                            </option>`
                                        ).join('')}
                                    </select>
                                </div>
                            `;
                        }
                        
                        // Debug: log the selected track data
                        console.log(`🔍 Track ${match.position} Spotify data:`, selectedTrack);
                        console.log(`🔍 Artists array:`, selectedTrack.artists);
                        console.log(`🔍 Single artist:`, selectedTrack.artist);
                        
                        spotifyInfo = `
                            ${matchSelector}
                            <div class="album-cover-container" onclick="app.playTrack(${match.position})">
                                <img class="album-cover" src="${selectedTrack.album_artwork || '/placeholder-album.png'}" alt="Album Cover" onload="app.updateAlbumCoverBackground(this.parentElement, this.src)">
                                <div class="track-info">
                                    <div class="track-title" title="${selectedTrack.name}">${selectedTrack.name}</div>
                                    <div class="track-artist" title="${selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist}">${selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        console.log(`❌ No match for track ${match.position}: ${match.error || 'No match found'}`);
                        spotifyInfo = `
                            <div class="spotify-no-match">
                                <span class="no-match-text">No Spotify match found</span>
                                ${match.error ? `<span class="error-text">(${match.error})</span>` : ''}
                            </div>
                        `;
                    }

                    spotifyContainer.outerHTML = spotifyInfo;
                    
                    // Update track info to show multiple matches indicator and mismatch warnings
                    const trackInfo = trackElement.querySelector('.chart-track-info');
                    
                    // Clear existing classes
                    trackInfo.classList.remove('has-multiple-matches', 'has-mismatch');
                    
                    // Add multiple matches indicator
                    if (match.hasMatch && match.spotifyMatches && match.spotifyMatches.length > 1) {
                        trackInfo.classList.add('has-multiple-matches');
                    }
                    
                    // Check for mismatches
                    if (match.hasMatch && match.spotifyMatches && match.spotifyMatches.length > 0) {
                        const selectedIndex = match.selectedMatch || 0;
                        const selectedTrack = match.spotifyMatches[selectedIndex];
                        
                        const mismatch = this.detectMismatch(
                            match.title, 
                            match.artist, 
                            selectedTrack.name, 
                            selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist
                        );
                        
                        if (mismatch.hasMismatch && !match.accepted) {
                            trackInfo.classList.add('has-mismatch');
                            
                            // Add tooltip with mismatch details
                            let tooltip = trackInfo.querySelector('.mismatch-tooltip');
                            if (!tooltip) {
                                tooltip = document.createElement('div');
                                tooltip.className = 'mismatch-tooltip';
                                trackInfo.appendChild(tooltip);
                            }
                            
                            tooltip.innerHTML = `
                                <strong>⚠️ Potential Mismatch:</strong><br>
                                ${mismatch.issues.join('<br>')}
                            `;
                            
                            // Add accept button
                            let acceptBtn = trackInfo.querySelector('.accept-match-btn');
                            if (!acceptBtn) {
                                acceptBtn = document.createElement('button');
                                acceptBtn.className = 'accept-match-btn';
                                acceptBtn.textContent = 'Accept';
                                acceptBtn.onclick = (e) => {
                                    e.stopPropagation();
                                    this.acceptMatch(match.position);
                                };
                                trackInfo.appendChild(acceptBtn);
                            }
                            
                            // Add fetch more button if there are multiple matches
                            if (match.spotifyMatches && match.spotifyMatches.length > 1) {
                                let fetchMoreBtn = trackInfo.querySelector('.fetch-more-btn');
                                if (!fetchMoreBtn) {
                                    fetchMoreBtn = document.createElement('button');
                                    fetchMoreBtn.className = 'fetch-more-btn';
                                    fetchMoreBtn.textContent = 'More';
                                    fetchMoreBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        this.fetchMoreMatches(match.position);
                                    };
                                    trackInfo.appendChild(fetchMoreBtn);
                                }
                            }
                            
                            console.log(`⚠️ Mismatch detected for position ${match.position}: ${mismatch.issues.join(', ')}`);
                        }
                    }
                });
                
                        // Add event listeners for match dropdowns
                        this.setupMatchDropdowns();
                        
                        // Add fetch more buttons for tracks with multiple matches
                        this.addFetchMoreButtons();
                
                console.log('✅ Finished updating tracks with matches');
                
                // Mark tracks as loaded
                this.tracksLoaded = true;
                
                // Apply default filter (show only tracks needing verification) after a short delay
                // to ensure DOM is fully updated
                setTimeout(() => {
                    this.showTracksNeedingVerification();
                }, 100);
            }

            setupMatchDropdowns() {
                const dropdowns = document.querySelectorAll('.match-dropdown');
                console.log(`🔍 Setting up ${dropdowns.length} dropdown event listeners`);
                dropdowns.forEach(dropdown => {
                    this.setupDropdownEventListener(dropdown);
                });
            }

            setupDropdownEventListener(dropdown) {
                // Remove any existing event listeners to avoid duplicates
                const newDropdown = dropdown.cloneNode(true);
                dropdown.parentNode.replaceChild(newDropdown, dropdown);
                
                // Add the event listener to the new dropdown
                newDropdown.addEventListener('change', (e) => {
                    const position = parseInt(e.target.dataset.position);
                    const matchIndex = parseInt(e.target.value);
                    console.log(`🔄 Dropdown changed: position=${position}, matchIndex=${matchIndex}`);
                    this.selectMatch(position, matchIndex);
                });
                
                console.log(`✅ Set up event listener for dropdown at position ${newDropdown.dataset.position}`);
            }

            selectMatch(position, matchIndex) {
                console.log(`🔍 selectMatch called: position=${position}, matchIndex=${matchIndex}`);
                
                // Find the match data for this position
                const matchData = this.currentMatches?.find(m => m.position === position);
                if (!matchData || !matchData.spotifyMatches) {
                    console.warn(`❌ No match data found for position ${position}`);
                    return;
                }

                console.log(`✅ Found match data for position ${position}, updating to match ${matchIndex}`);
                
                // Update the selected match
                matchData.selectedMatch = matchIndex;
                const selectedTrack = matchData.spotifyMatches[matchIndex];

                // Update the album cover and track info
                const albumCover = document.querySelector(`#track-element-${position} .album-cover`);
                const trackTitle = document.querySelector(`#track-element-${position} .track-title`);
                const trackArtist = document.querySelector(`#track-element-${position} .track-artist`);
                const albumCoverContainer = document.querySelector(`#track-element-${position} .album-cover-container`);
                
                if (albumCover && selectedTrack) {
                    albumCover.src = selectedTrack.album_artwork || '/placeholder-album.png';
                    // Update background color when image loads
                    albumCover.onload = () => {
                        this.updateAlbumCoverBackground(albumCoverContainer, albumCover.src);
                    };
                }
                if (trackTitle && selectedTrack) {
                    trackTitle.textContent = selectedTrack.name;
                    trackTitle.title = selectedTrack.name;
                }
                if (trackArtist && selectedTrack) {
                    trackArtist.textContent = selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist;
                    trackArtist.title = selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist;
                }

                // Re-check for mismatches with the new selection
                const trackInfo = document.querySelector(`#track-element-${position} .chart-track-info`);
                console.log(`🔍 Looking for trackInfo element: #track-element-${position} .chart-track-info`);
                console.log(`🔍 Found trackInfo:`, trackInfo);
                
                if (trackInfo) {
                    // Clear existing classes
                    trackInfo.classList.remove('has-mismatch');
                    
                    // Remove existing tooltip
                    const existingTooltip = trackInfo.querySelector('.mismatch-tooltip');
                    if (existingTooltip) {
                        existingTooltip.remove();
                    }
                    
                    // Check for mismatches with new selection
                    const mismatch = this.detectMismatch(
                        matchData.title, 
                        matchData.artist, 
                        selectedTrack.name, 
                        selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist
                    );
                    
                    console.log(`🔍 Checking mismatch for position ${position}:`, {
                        original: `${matchData.title} by ${matchData.artist}`,
                        selected: `${selectedTrack.name} by ${selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist}`,
                        hasMismatch: mismatch.hasMismatch,
                        accepted: matchData.accepted,
                        issues: mismatch.issues
                    });
                    
                    // Always show accept button when an alternative is selected (unless already accepted)
                    if (!matchData.accepted) {
                        console.log(`🔍 Adding accept button for position ${position} (not yet accepted)`);
                        
                        // Remove any existing accept button first
                        const existingAcceptBtn = trackInfo.querySelector('.accept-match-btn');
                        if (existingAcceptBtn) {
                            console.log(`🗑️ Removing existing accept button for position ${position}`);
                            existingAcceptBtn.remove();
                        }
                        
                        // Add accept button for any selection change
                        const acceptBtn = document.createElement('button');
                        acceptBtn.className = 'accept-match-btn';
                        acceptBtn.textContent = 'Accept';
                        acceptBtn.onclick = (e) => {
                            e.stopPropagation();
                            this.acceptMatch(position);
                        };
                        trackInfo.appendChild(acceptBtn);
                        
                        console.log(`✅ Accept button added for position ${position} (alternative selected)`);
                        
                        // Add mismatch styling and tooltip if there's a mismatch
                        if (mismatch.hasMismatch) {
                            trackInfo.classList.add('has-mismatch');
                            
                            // Add tooltip with mismatch details
                            const tooltip = document.createElement('div');
                            tooltip.className = 'mismatch-tooltip';
                            tooltip.innerHTML = `
                                <strong>⚠️ Potential Mismatch:</strong><br>
                                ${mismatch.issues.join('<br>')}
                            `;
                            trackInfo.appendChild(tooltip);
                            
                            console.log(`⚠️ Mismatch detected for position ${position}: ${mismatch.issues.join(', ')}`);
                        }
                    } else {
                        console.log(`ℹ️ No accept button needed for position ${position} (already accepted)`);
                    }
                }

                console.log(`🎵 Updated track ${position} to use match ${matchIndex}: ${selectedTrack.name}`);
                
                // Update the embedded player if it's currently showing this track
                const playerContainer = document.getElementById('singlePlayer');
                if (playerContainer && playerContainer.classList.contains('show')) {
                    // Check if the player is currently showing this position
                    const currentPlayerTrack = playerContainer.dataset.currentPosition;
                    if (currentPlayerTrack && parseInt(currentPlayerTrack) === position) {
                        console.log(`🔄 Updating embedded player to reflect new selection for position ${position}`);
                        this.playTrack(position);
                    }
                }
            }

            toggleMatchSelector(position) {
                const matchSelector = document.getElementById(`match-selector-${position}`);
                if (!matchSelector) return;

                // Toggle the expanded class
                matchSelector.classList.toggle('expanded');
                
                console.log(`🔄 Toggled match selector for position ${position}`);
            }

            acceptMatch(position) {
                // Find the match data for this position
                const matchData = this.currentMatches?.find(m => m.position === position);
                if (!matchData) return;

                // Mark as accepted
                matchData.accepted = true;

                // Update the UI to remove the mismatch warning
                const trackInfo = document.querySelector(`#track-element-${position} .chart-track-info`);
                if (trackInfo) {
                    trackInfo.classList.remove('has-mismatch');
                    
                    // Remove tooltip and accept button
                    const tooltip = trackInfo.querySelector('.mismatch-tooltip');
                    const acceptBtn = trackInfo.querySelector('.accept-match-btn');
                    if (tooltip) tooltip.remove();
                    if (acceptBtn) acceptBtn.remove();
                }

                // Check if we should hide this track from the filtered view
                const showAllCheckbox = document.getElementById('showAllTracks');
                if (!showAllCheckbox.checked) {
                    // We're in "show only tracks needing verification" mode
                    // Since this track no longer needs verification, hide it
                    const trackElement = document.querySelector(`#track-element-${position}`);
                    if (trackElement) {
                        trackElement.style.display = 'none';
                        console.log(`✅ Track ${position} accepted and hidden from verification view`);
                    }
                }

                // Save to cache
                this.saveAcceptedMatchToCache(position);

                console.log(`✅ Accepted match for position ${position}: ${matchData.title} by ${matchData.artist}`);
            }

            saveAcceptedMatchToCache(position) {
                if (!this.selectedYear) return;

                try {
                    const cacheKey = `accepted_matches_${this.selectedYear}`;
                    let acceptedMatches = JSON.parse(localStorage.getItem(cacheKey) || '{}');
                    
                    // Find the match data
                    const matchData = this.currentMatches?.find(m => m.position === position);
                    if (matchData) {
                        const selectedIndex = matchData.selectedMatch || 0;
                        const selectedTrack = matchData.spotifyMatches[selectedIndex];
                        
                        // Store the accepted match info
                        acceptedMatches[position] = {
                            title: matchData.title,
                            artist: matchData.artist,
                            spotifyId: selectedTrack.id,
                            spotifyUri: selectedTrack.uri,
                            acceptedAt: new Date().toISOString()
                        };
                        
                        localStorage.setItem(cacheKey, JSON.stringify(acceptedMatches));
                        console.log(`💾 Saved accepted match for position ${position} to cache`);
                    }
                } catch (error) {
                    console.error('Error saving accepted match to cache:', error);
                }
            }

            loadAcceptedMatchesFromCache(year) {
                try {
                    const cacheKey = `accepted_matches_${year}`;
                    const acceptedMatches = JSON.parse(localStorage.getItem(cacheKey) || '{}');
                    
                    // Apply accepted matches to current matches
                    if (this.currentMatches) {
                        this.currentMatches.forEach(match => {
                            if (acceptedMatches[match.position]) {
                                match.accepted = true;
                            }
                        });
                    }
                    
                    console.log(`📂 Loaded ${Object.keys(acceptedMatches).length} accepted matches from cache for ${year}`);
                    return acceptedMatches;
                } catch (error) {
                    console.error('Error loading accepted matches from cache:', error);
                    return {};
                }
            }

            addFetchMoreButtons() {
                if (!this.currentMatches) return;
                
                this.currentMatches.forEach(match => {
                    if (match.spotifyMatches && match.spotifyMatches.length > 1) {
                        const trackInfo = document.querySelector(`#track-element-${match.position} .chart-track-info`);
                        if (trackInfo && !trackInfo.querySelector('.fetch-more-btn')) {
                            const fetchMoreBtn = document.createElement('button');
                            fetchMoreBtn.className = 'fetch-more-btn';
                            fetchMoreBtn.textContent = 'More';
                            fetchMoreBtn.onclick = (e) => {
                                e.stopPropagation();
                                this.fetchMoreMatches(match.position);
                            };
                            trackInfo.appendChild(fetchMoreBtn);
                        }
                    }
                });
            }

            async fetchMoreMatches(position) {
                const matchData = this.currentMatches?.find(m => m.position === position);
                if (!matchData) return;

                const fetchMoreBtn = document.querySelector(`#track-element-${position} .fetch-more-btn`);
                if (fetchMoreBtn) {
                    fetchMoreBtn.disabled = true;
                    fetchMoreBtn.textContent = '...';
                }

                try {
                    console.log(`🔍 Fetching more matches for position ${position}: ${matchData.title} by ${matchData.artist}`);
                    console.log(`🔍 Search query: "${matchData.searchQuery}"`);
                    console.log(`🔍 Match data:`, matchData);
                    
                    const requestBody = {
                        position: position,
                        title: matchData.title,
                        artist: matchData.artist,
                        searchQuery: matchData.searchQuery
                    };
                    console.log(`🔍 Request body:`, requestBody);
                    
                    const response = await fetch('/api/fetch-more-matches', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    console.log(`🔍 Response status: ${response.status}`);
                    console.log(`🔍 Response ok: ${response.ok}`);

                    const data = await response.json();
                    console.log(`🔍 Response data:`, data);
                    
                    if (response.ok && data.additionalMatches) {
                        // Add new matches to existing ones
                        matchData.spotifyMatches.push(...data.additionalMatches);
                        
                        // Update the dropdown with new options
                        this.updateMatchDropdown(position, matchData.spotifyMatches);
                        
                        console.log(`✅ Added ${data.additionalMatches.length} more matches for position ${position}`);
                        this.showAlert(`Found ${data.additionalMatches.length} additional matches!`, 'success');
                    } else {
                        this.showAlert(data.error || 'Failed to fetch more matches', 'error');
                    }
                } catch (error) {
                    console.error('Error fetching more matches:', error);
                    this.showAlert('Network error. Please try again.', 'error');
                } finally {
                    if (fetchMoreBtn) {
                        fetchMoreBtn.disabled = false;
                        fetchMoreBtn.textContent = 'More';
                    }
                }
            }

            updateMatchDropdown(position, allMatches) {
                const dropdown = document.querySelector(`#match-selector-${position} select`);
                if (!dropdown) return;

                // Store current selection
                const currentSelection = dropdown.value;
                
                // Clear and repopulate dropdown
                dropdown.innerHTML = '';
                
                allMatches.forEach((match, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${match.name} - ${match.artist} (${match.popularity || 0}%)`;
                    if (index.toString() === currentSelection) {
                        option.selected = true;
                    }
                    dropdown.appendChild(option);
                });
                
                console.log(`🔄 Updated dropdown for position ${position} with ${allMatches.length} total matches`);
                
                // Re-setup event listener for this specific dropdown
                this.setupDropdownEventListener(dropdown);
            }

            populatePlaylistSelector() {
                const selector = document.getElementById('playlistSelector');
                if (!selector || !this.currentExistingPlaylists) return;

                // Clear existing options except the first one
                selector.innerHTML = '<option value="">Select a playlist...</option>';

                // Add existing playlists
                this.currentExistingPlaylists.forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.id;
                    option.textContent = `${playlist.name} (${playlist.tracks?.total || 0} tracks)`;
                    selector.appendChild(option);
                });

                console.log(`📋 Populated playlist selector with ${this.currentExistingPlaylists.length} playlists`);
            }

            detectMismatch(originalTitle, originalArtist, spotifyTitle, spotifyArtist) {
                const issues = [];
                
                // Normalize strings for comparison
                const normalize = (str) => str.toLowerCase()
                    .replace(/[^\w\s]/g, '') // Remove punctuation
                    .replace(/\s+/g, ' ') // Normalize whitespace
                    .trim();
                
                const normOriginalTitle = normalize(originalTitle);
                const normOriginalArtist = normalize(originalArtist);
                const normSpotifyTitle = normalize(spotifyTitle);
                const normSpotifyArtist = normalize(spotifyArtist);
                
                // Check title similarity
                const titleSimilarity = this.calculateStringSimilarity(normOriginalTitle, normSpotifyTitle);
                if (titleSimilarity < 0.7) {
                    issues.push(`Title mismatch: "${originalTitle}" vs "${spotifyTitle}"`);
                }
                
                // Check artist similarity
                const artistSimilarity = this.calculateStringSimilarity(normOriginalArtist, normSpotifyArtist);
                if (artistSimilarity < 0.7) {
                    issues.push(`Artist mismatch: "${originalArtist}" vs "${spotifyArtist}"`);
                }
                
                // Check for obvious red flags
                const spotifyLower = spotifyTitle.toLowerCase() + ' ' + spotifyArtist.toLowerCase();
                if (spotifyLower.includes('cover') || spotifyLower.includes('tribute') || 
                    spotifyLower.includes('karaoke') || spotifyLower.includes('instrumental') ||
                    spotifyLower.includes('party') || spotifyLower.includes('remix')) {
                    issues.push('Possible cover/remix version');
                }
                
                return {
                    hasMismatch: issues.length > 0,
                    issues: issues,
                    titleSimilarity: titleSimilarity,
                    artistSimilarity: artistSimilarity
                };
            }

            calculateStringSimilarity(str1, str2) {
                if (str1 === str2) return 1.0;
                if (str1.length === 0 || str2.length === 0) return 0.0;
                
                const longer = str1.length > str2.length ? str1 : str2;
                const shorter = str1.length > str2.length ? str2 : str1;
                
                const editDistance = this.levenshteinDistance(longer, shorter);
                return (longer.length - editDistance) / longer.length;
            }

            levenshteinDistance(str1, str2) {
                const matrix = [];
                
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            updateSelectedCount() {
                const checkboxes = document.querySelectorAll('#chartList input[type="checkbox"]:checked');
                const count = checkboxes.length;
                document.getElementById('selectedCount').textContent = `${count} tracks selected`;
            }

            selectAllTracks() {
                document.querySelectorAll('#chartList input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = true;
                });
                this.updateSelectedCount();
            }

            selectNoTracks() {
                document.querySelectorAll('#chartList input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                this.updateSelectedCount();
            }

            showStep2() {
                document.getElementById('step1').classList.add('hidden');
                document.getElementById('step2').classList.remove('hidden');
            }

            backToStep1() {
                document.getElementById('step2').classList.add('hidden');
                document.getElementById('step1').classList.remove('hidden');
                this.currentChartData = null;
            }

            async createPlaylist() {
                if (!this.currentChartData) {
                    this.showAlert('No chart data loaded. Please go back to step 1.', 'error');
                    return;
                }

                const year = document.getElementById('year').value;
                const playlistName = document.getElementById('playlistName').value;
                const isPublic = document.getElementById('isPublic').checked;

                // Get all matched tracks from the UI (not just selected ones)
                const allMatchedTracks = this.getAllMatchedTracks();
                
                if (allMatchedTracks.length === 0) {
                    this.showAlert('No Spotify matches found. Please wait for tracks to load or try a different year.', 'error');
                    return;
                }

                this.showLoading(true, 'Creating Spotify playlist...');
                this.hidePlaylistResult();

                try {
                    const response = await fetch('/api/create-playlist', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            year: parseInt(year),
                            playlistName: playlistName || undefined,
                            isPublic: isPublic,
                            matchedTracks: allMatchedTracks
                        })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        this.showPlaylistResult(data.playlist);
                        this.showAlert(`Playlist "${data.playlist.name}" created successfully!`, 'success');
                    } else {
                        this.showAlert(data.error || 'Failed to create playlist', 'error');
                    }
                } catch (error) {
                    console.error('Create playlist error:', error);
                    this.showAlert('Network error. Please try again.', 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            async updatePlaylist() {
                const playlistSelector = document.getElementById('playlistSelector');
                const selectedPlaylistId = playlistSelector.value;
                
                if (!selectedPlaylistId) {
                    this.showAlert('Please select a playlist to add tracks to', 'error');
                    return;
                }

                const selectedTracks = this.getSelectedTracks();
                if (selectedTracks.length === 0) {
                    this.showAlert('Please select at least one track to add', 'error');
                    return;
                }

                const year = document.getElementById('year').value;
                const replaceAll = document.getElementById('replaceAllTracks').checked;

                this.showLoading(true, 'Adding tracks to playlist...');

                try {
                    const response = await fetch('/api/update-playlist', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            playlistId: selectedPlaylistId,
                            year: year,
                            selectedTracks: selectedTracks,
                            replaceAll: replaceAll
                        })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        this.showPlaylistResult(data.playlist);
                        this.showAlert(`Tracks added successfully! Added ${selectedTracks.length} tracks to playlist.`, 'success');
                    } else {
                        this.showAlert(data.error || 'Failed to add tracks to playlist', 'error');
                    }
                } catch (error) {
                    console.error('Update playlist error:', error);
                    this.showAlert('Network error. Please try again.', 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            getSelectedTracks() {
                const checkboxes = document.querySelectorAll('#chartList input[type="checkbox"]:checked');
                const selectedTracks = [];
                
                checkboxes.forEach(checkbox => {
                    const position = parseInt(checkbox.dataset.position);
                    const matchData = this.currentMatches?.find(m => m.position === position);
                    
                    if (matchData && matchData.hasMatch && matchData.spotifyMatches && matchData.spotifyMatches.length > 0) {
                        const selectedIndex = matchData.selectedMatch || 0;
                        const selectedTrack = matchData.spotifyMatches[selectedIndex];
                        
                        selectedTracks.push({
                            position: position,
                            title: matchData.title,
                            artist: matchData.artist,
                            spotifyUri: selectedTrack.uri,
                            spotifyId: selectedTrack.id
                        });
                    }
                });
                
                return selectedTracks;
            }

            getAllMatchedTracks() {
                if (!this.currentMatches) return [];
                
                const allMatchedTracks = [];
                
                this.currentMatches.forEach(matchData => {
                    if (matchData.hasMatch && matchData.spotifyMatches && matchData.spotifyMatches.length > 0) {
                        const selectedIndex = matchData.selectedMatch || 0;
                        const selectedTrack = matchData.spotifyMatches[selectedIndex];
                        
                        allMatchedTracks.push({
                            position: matchData.position,
                            title: matchData.title,
                            artist: matchData.artist,
                            spotifyUri: selectedTrack.uri,
                            spotifyId: selectedTrack.id
                        });
                    }
                });
                
                return allMatchedTracks;
            }

            // Local storage caching methods
            getCachedChartData(year) {
                try {
                    const cacheKey = `uk-charts-${year}`;
                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const data = JSON.parse(cached);
                        // Check if cache is still valid (less than 24 hours old)
                        const cacheAge = Date.now() - data.timestamp;
                        const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                        if (cacheAge < maxAge) {
                            return data.chartData;
                        } else {
                            // Cache expired, remove it
                            localStorage.removeItem(cacheKey);
                        }
                    }
                } catch (error) {
                    console.warn('Error reading cached chart data:', error);
                }
                return null;
            }

            cacheChartData(year, chartData) {
                try {
                    const cacheKey = `uk-charts-${year}`;
                    const cacheData = {
                        chartData: chartData,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                } catch (error) {
                    console.warn('Error caching chart data:', error);
                }
            }

            clearCachedChartData(year) {
                try {
                    const cacheKey = `uk-charts-${year}`;
                    localStorage.removeItem(cacheKey);
                } catch (error) {
                    console.warn('Error clearing cached chart data:', error);
                }
            }

            clearAllCachedData() {
                try {
                    const keys = Object.keys(localStorage);
                    keys.forEach(key => {
                        if (key.startsWith('uk-charts-')) {
                            localStorage.removeItem(key);
                        }
                    });
                    console.log('🗑️ Cleared all cached chart data');
                } catch (error) {
                    console.warn('Error clearing all cached data:', error);
                }
            }

            showLoading(show, text = 'Loading...') {
                const loading = document.getElementById('loading');
                const loadingText = document.getElementById('loadingText');
                
                if (show) {
                    loadingText.textContent = text;
                    loading.classList.add('show');
                } else {
                    loading.classList.remove('show');
                }
            }

            showPlaylistResult(playlist) {
                document.getElementById('tracksFound').textContent = playlist.tracksFound;
                document.getElementById('tracksSearched').textContent = playlist.tracksSearched;
                document.getElementById('playlistYear').textContent = playlist.year;
                document.getElementById('playlistLink').href = playlist.url;
                document.getElementById('playlistResult').classList.add('show');
            }

            hidePlaylistResult() {
                document.getElementById('playlistResult').classList.remove('show');
            }

            showAlert(message, type = 'info') {
                const alert = document.getElementById('alert');
                alert.textContent = message;
                alert.className = `alert alert-${type} show`;
                
                setTimeout(() => {
                    alert.classList.remove('show');
                }, 5000);
            }

            handleURLParams() {
                const urlParams = new URLSearchParams(window.location.search);
                const success = urlParams.get('success');
                const error = urlParams.get('error');
                
                if (success) {
                    this.showAlert('Successfully logged in to Spotify!', 'success');
                } else if (error) {
                    this.showAlert(`Login error: ${decodeURIComponent(error)}`, 'error');
                }
                
                // Clean up URL
                if (success || error) {
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }

            loadStateFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const year = urlParams.get('year');
                const refresh = urlParams.get('refresh');
                
                if (year) {
                    console.log(`📋 Loading state from URL: year=${year}, refresh=${refresh}`);
                    
                    // Set the year select
                    const yearSelect = document.getElementById('year');
                    if (yearSelect) {
                        yearSelect.value = year;
                        this.selectedYear = year;
                        console.log(`✅ Set year select to: ${year}`);
                    } else {
                        console.error('❌ Year select element not found');
                    }
                    
                    // Set refresh flag
                    if (refresh === 'true') {
                        this.forceRefresh = true;
                        console.log(`✅ Set force refresh flag to true`);
                    }
                    
                    // Auto-start chart loading if year is valid
                    if (this.isValidYear(year)) {
                        console.log(`🚀 Auto-starting chart loading for year ${year}`);
                        setTimeout(() => {
                            this.loadChartData(null, this.forceRefresh);
                        }, 500); // Small delay to ensure UI is ready
                    }
                }
            }

            updateURL(year = null, refresh = null) {
                const url = new URL(window.location);
                
                if (year !== null) {
                    if (year) {
                        url.searchParams.set('year', year);
                    } else {
                        url.searchParams.delete('year');
                    }
                }
                
                if (refresh !== null) {
                    if (refresh) {
                        url.searchParams.set('refresh', 'true');
                    } else {
                        url.searchParams.delete('refresh');
                    }
                }
                
                // Update URL without triggering page reload
                window.history.replaceState({}, document.title, url.toString());
                console.log(`🔗 Updated URL: ${url.toString()}`);
            }

            playTrack(position) {
                const matchData = this.currentMatches?.find(m => m.position === position);
                if (!matchData || !matchData.spotifyMatches) {
                    console.warn(`No match data found for position ${position}`);
                    return;
                }

                // Use the currently selected match (or default to 0)
                const matchIndex = matchData.selectedMatch || 0;
                const selectedTrack = matchData.spotifyMatches[matchIndex];
                
                if (!selectedTrack) {
                    console.warn(`No track found for position ${position}, match ${matchIndex}`);
                    return;
                }
                console.log(`🎵 Playing track: ${selectedTrack.name} by ${selectedTrack.artists ? selectedTrack.artists.join(', ') : selectedTrack.artist}`);

                // Update single player
                const playerContainer = document.getElementById('singlePlayer');
                const playerIframe = document.getElementById('playerIframe');

                if (playerIframe) {
                    playerIframe.src = `https://open.spotify.com/embed/track/${selectedTrack.id}?utm_source=generator`;
                }

                // Show the player
                if (playerContainer) {
                    playerContainer.classList.add('show');
                    playerContainer.dataset.currentPosition = position;
                    // Reset display style in case it was set to none
                    playerContainer.style.display = '';
                }
            }

            closePlayer() {
                console.log('🔴 Close player button clicked - closePlayer method called');
                const playerContainer = document.getElementById('singlePlayer');
                if (playerContainer) {
                    console.log('🔴 Removing show class from player container');
                    playerContainer.classList.remove('show');
                    // Also set display to none as backup
                    playerContainer.style.display = 'none';
                    console.log('🔴 Player should now be hidden');
                } else {
                    console.error('❌ Player container not found');
                }
            }

            extractDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    let r = 0, g = 0, b = 0;
                    let pixelCount = 0;
                    
                    // Sample every 10th pixel for performance
                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        pixelCount++;
                    }
                    
                    r = Math.floor(r / pixelCount);
                    g = Math.floor(g / pixelCount);
                    b = Math.floor(b / pixelCount);
                    
                    // Darken the color by 30%
                    r = Math.floor(r * 0.7);
                    g = Math.floor(g * 0.7);
                    b = Math.floor(b * 0.7);
                    
                    const color = `rgb(${r}, ${g}, ${b})`;
                    callback(color);
                };
                img.onerror = function() {
                    callback('#333333'); // Fallback dark color
                };
                img.src = imageUrl;
            }

            updateAlbumCoverBackground(container, imageUrl) {
                this.extractDominantColor(imageUrl, (color) => {
                    container.style.background = color;
                });
            }
        }

        // Global function for close button
        function closePlayer() {
            console.log('🔴 Close player button clicked - global function called');
            const playerContainer = document.getElementById('singlePlayer');
            console.log('🔴 Player container found:', playerContainer);
            if (playerContainer) {
                console.log('🔴 Current classes:', playerContainer.className);
                console.log('🔴 Removing show class from player container');
                playerContainer.classList.remove('show');
                console.log('🔴 Player should now be hidden');
                console.log('🔴 New classes:', playerContainer.className);
                console.log('🔴 Computed display style:', window.getComputedStyle(playerContainer).display);
            } else {
                console.error('❌ Player container not found');
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 DOM Content Loaded, initializing app...');
            const app = new UKChartsApp();
            
            // Make app globally accessible for onclick handlers
            window.app = app;
            console.log('✅ App made globally accessible');
            
            // Test if closePlayer function is available
            console.log('🔍 Testing closePlayer function:', typeof closePlayer);
            
            // Load state from URL parameters
            app.loadStateFromURL();
            
            // Add event listener for player close button
            console.log('🔍 Looking for player close button...');
            const playerCloseBtn = document.getElementById('playerClose');
            console.log('🔍 Player close button element:', playerCloseBtn);
            
            if (playerCloseBtn) {
                console.log('✅ Player close button found, adding event listener');
                playerCloseBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🔴 Close button clicked - event fired!');
                    app.closePlayer();
                });
                console.log('✅ Event listener added successfully');
            } else {
                console.error('❌ Player close button not found - element does not exist');
                // Let's also check if the player container exists
                const playerContainer = document.getElementById('singlePlayer');
                console.log('🔍 Player container element:', playerContainer);
                
                // Add event delegation as fallback
                console.log('🔄 Adding event delegation fallback...');
                document.addEventListener('click', (e) => {
                    if (e.target && e.target.id === 'playerClose') {
                        console.log('🔴 Close button clicked via event delegation!');
                        e.preventDefault();
                        e.stopPropagation();
                        app.closePlayer();
                    }
                });
                console.log('✅ Event delegation fallback added');
            }
        });
    </script>
</body>
</html>
